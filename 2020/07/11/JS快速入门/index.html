<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JS快速入门 | 黑刀的个人博客</title>
  <meta name="keywords" content=" 前端 , JavaScript ">
  <meta name="description" content="JS快速入门 | 黑刀的个人博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="第一个 Vue 程序首先导入开发版本的 Vue.js &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; 创建 Vue 实例对象，设置 el 属性和 data 属性： &lt;div id&#x3D;&amp;quot">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue入门基础">
<meta property="og:url" content="http://yoursite.com/2020/09/29/Vue%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="黑刀的个人博客">
<meta property="og:description" content="第一个 Vue 程序首先导入开发版本的 Vue.js &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; 创建 Vue 实例对象，设置 el 属性和 data 属性： &lt;div id&#x3D;&amp;quot">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-29T14:14:41.000Z">
<meta property="article:modified_time" content="2020-10-31T16:28:45.594Z">
<meta property="article:author" content="黑刀">
<meta property="article:tag" content="黑刀">
<meta property="article:tag" content=" BlackKnife">
<meta property="article:tag" content=" 云游四海">
<meta property="article:tag" content=" 播客">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
</div>


<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>黑刀</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/BlckKn1fe" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:lding1003@gmail.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=553658519&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=121733025" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active" data-rel="全部文章">全部文章<small>(16)</small></div></li>
    
        
            
            <li><div data-rel="Java">Java<small>(6)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="前端">前端<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="设计模式">设计模式<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Linux">Linux<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="MySQL">MySQL<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="16">
<input type="hidden" id="yelog_site_word_count" value="82.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://flowermushroom.github.io">花蘑菇</a></li>
            
            <li><a target="_blank" href="https://www.yeliulee.com/">琉璃</a></li>
            
            <li><a target="_blank" href="https://nightrainlemon.github.io/">夜雨柠檬</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>反射</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>前端</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>BOM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DOM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTML</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Javaweb</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Note</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 "
           href="/2020/09/29/Vue%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Vue入门基础">Vue入门基础</span>
            <span class="post-date" title="2020-09-29 22:14:41">2020/09/29</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2020/09/08/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/"
           data-tag="Java,Note,Javaweb,反射"
           data-author="" >
            <span class="post-title" title="反射和注解">反射和注解</span>
            <span class="post-date" title="2020-09-08 20:11:47">2020/09/08</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020/09/03/DOM-BOM%E6%93%8D%E4%BD%9C/"
           data-tag="前端,JavaScript,DOM,BOM"
           data-author="" >
            <span class="post-title" title="DOM/BOM操作">DOM/BOM操作</span>
            <span class="post-date" title="2020-09-03 08:14:08">2020/09/03</span>
        </a>
        
        <a  class="全部文章 Linux "
           href="/2020/09/03/%E4%B8%80%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E6%8C%87%E4%BB%A4/"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="一天一个Linux指令">一天一个Linux指令</span>
            <span class="post-date" title="2020-09-03 08:13:58">2020/09/03</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020/07/21/H5-C3%E6%8F%90%E9%AB%98/"
           data-tag="前端,HTML,CSS"
           data-author="" >
            <span class="post-title" title="H5/C3提高">H5/C3提高</span>
            <span class="post-date" title="2020-07-21 11:40:31">2020/07/21</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020/07/11/JS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"
           data-tag="前端,JavaScript"
           data-author="" >
            <span class="post-title" title="JS快速入门">JS快速入门</span>
            <span class="post-date" title="2020-07-11 05:02:30">2020/07/11</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020/06/28/CSS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="CSS基础笔记">CSS基础笔记</span>
            <span class="post-date" title="2020-06-28 01:51:40">2020/06/28</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020/06/19/MySQL%E5%9F%BA%E7%A1%80/"
           data-tag="Note,MySQL"
           data-author="" >
            <span class="post-title" title="MySQL基础">MySQL基础</span>
            <span class="post-date" title="2020-06-19 15:04:54">2020/06/19</span>
        </a>
        
        <a  class="全部文章 Linux "
           href="/2020/06/14/Ubuntu%E9%85%8D%E7%BD%AE/"
           data-tag="Linux,MySQL"
           data-author="" >
            <span class="post-title" title="Ubuntu配置">Ubuntu配置</span>
            <span class="post-date" title="2020-06-14 10:52:25">2020/06/14</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020/06/10/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89/"
           data-tag="Note,设计模式"
           data-author="" >
            <span class="post-title" title="单例设计模式（Singleton）">单例设计模式（Singleton）</span>
            <span class="post-date" title="2020-06-10 16:40:22">2020/06/10</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020/05/26/HTML%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"
           data-tag="前端,HTML"
           data-author="" >
            <span class="post-title" title="HTML基础笔记">HTML基础笔记</span>
            <span class="post-date" title="2020-05-26 03:16:36">2020/05/26</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2020/05/21/Java-Note-P5-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"
           data-tag="Java,Note"
           data-author="" >
            <span class="post-title" title="Java Note P5 (黑马程序员)">Java Note P5 (黑马程序员)</span>
            <span class="post-date" title="2020-05-21 19:57:31">2020/05/21</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2020/03/05/Java-Note-P4-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"
           data-tag="Java,Note"
           data-author="" >
            <span class="post-title" title="Java Note P4 (黑马程序员)">Java Note P4 (黑马程序员)</span>
            <span class="post-date" title="2020-03-05 17:40:06">2020/03/05</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2019/11/18/Java-Note-P3-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"
           data-tag="Java,Note"
           data-author="" >
            <span class="post-title" title="Java Note P3 (黑马程序员)">Java Note P3 (黑马程序员)</span>
            <span class="post-date" title="2019-11-18 12:43:23">2019/11/18</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2019/10/15/Java-Note-P2-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"
           data-tag="Java,Note"
           data-author="" >
            <span class="post-title" title="Java Note P2 (黑马程序员）">Java Note P2 (黑马程序员）</span>
            <span class="post-date" title="2019-10-15 23:39:14">2019/10/15</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2019/10/09/Java-Note-P1-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"
           data-tag="Java,Note"
           data-author="" >
            <span class="post-title" title="Java Note P1 (黑马程序员)">Java Note P1 (黑马程序员)</span>
            <span class="post-date" title="2019-10-09 00:33:50">2019/10/09</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-JS快速入门" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">JS快速入门</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="前端">前端</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">前端</a>
            
            <a class="color1">JavaScript</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2020-11-01 00:26:16'>2020-07-11 05:02</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:13.9k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#比较运算符"><span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null-和-undefined"><span class="toc-text">null 和 undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组和对象"><span class="toc-text">数组和对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strict-模式"><span class="toc-text">strict 模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多行字符串"><span class="toc-text">多行字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板字符串"><span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作字符串"><span class="toc-text">操作字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#先重点说两个"><span class="toc-text">先重点说两个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toUpperCase"><span class="toc-text">toUpperCase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toLowerCase"><span class="toc-text">toLowerCase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexOf"><span class="toc-text">indexOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#substring"><span class="toc-text">substring</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#slice"><span class="toc-text">slice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unshift和shift"><span class="toc-text">unshift和shift</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort"><span class="toc-text">sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#splice"><span class="toc-text">splice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concat"><span class="toc-text">concat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join"><span class="toc-text">join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象-1"><span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问属性"><span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改属性"><span class="toc-text">修改属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检查属性"><span class="toc-text">检查属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#循环"><span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#for…in"><span class="toc-text">for…in</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for…of"><span class="toc-text">for…of</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iterable"><span class="toc-text">iterable</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#导入导出模块"><span class="toc-text">导入导出模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义函数"><span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用函数"><span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arguments-和-Rest"><span class="toc-text">Arguments 和 Rest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量提升"><span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局作用域"><span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#名字空间"><span class="toc-text">名字空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局部作用域"><span class="toc-text">局部作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解构赋值"><span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rest操作符"><span class="toc-text">rest操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spread操作符"><span class="toc-text">spread操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解构赋值使用场景"><span class="toc-text">解构赋值使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply和call"><span class="toc-text">apply和call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰器"><span class="toc-text">装饰器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高阶函数"><span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reduce"><span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-reduce-小案例"><span class="toc-text">map + reduce 小案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort-1"><span class="toc-text">sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-text">Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包的脑洞"><span class="toc-text">闭包的脑洞</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#generator"><span class="toc-text">generator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象-2"><span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#包装（装箱）"><span class="toc-text">包装（装箱）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date"><span class="toc-text">Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RegExp"><span class="toc-text">RegExp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进阶"><span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪婪匹配"><span class="toc-text">贪婪匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#验证邮箱"><span class="toc-text">验证邮箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON"><span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化"><span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反序列化"><span class="toc-text">反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用API"><span class="toc-text">调用API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象-3"><span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建对象"><span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历对象属性"><span class="toc-text">遍历对象属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setter-amp-getter"><span class="toc-text">setter &amp; getter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型"><span class="toc-text">原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createXXX"><span class="toc-text">createXXX()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型继承"><span class="toc-text">原型继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小节"><span class="toc-text">小节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-text">class</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>这里笔记内容都是参考廖雪峰对于 JavaScript 教程而进行有针对性的提炼的</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312/</a></p>
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>JavaScript允许对任意数据类型做比较：</p>
<pre><code class="javascript">false == 0; // true
false === 0; // false</code></pre>
<p>有两种比较运算符：</p>
<p>第一种是<code>==</code>比较，<strong>它会自动转换数据类型再比较</strong>，很多时候，会得到非常诡异的结果；</p>
<p>第二种是<code>===</code>比较，<strong>它不会自动转换数据类型</strong>，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p>
<p>另一个例外是<code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：</p>
<pre><code class="javascript">NaN === NaN; // false</code></pre>
<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</p>
<pre><code class="javascript">isNaN(NaN); // true</code></pre>
<p>JavaScript把<code>null</code>、<code>undefined</code>、<code>0</code>、<code>NaN</code>和空字符串<code>&#39;&#39;</code>视为<code>false</code>，其他值一概视为<code>true</code>，因此上述代码条件判断的结果是<code>true</code>。</p>
<h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><p>在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</p>
<p>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</p>
<h2 id="数组和对象"><a href="#数组和对象" class="headerlink" title="数组和对象"></a>数组和对象</h2><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
<pre><code class="javascript">[1, 2, 3.14, &#39;Hello&#39;, null, true];</code></pre>
<p>另一种创建数组的方法是通过<code>Array()</code>函数实现：</p>
<pre><code>new Array(1, 2, 3); // 创建了数组[1, 2, 3]</code></pre><p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript的对象是一组由 <strong>键-值</strong> 组成的无序集合，例如：</p>
<pre><code class="javascript">var person = {
    name: &#39;Bob&#39;,
    age: 20,
    tags: [&#39;js&#39;, &#39;web&#39;, &#39;mobile&#39;],
    city: &#39;Beijing&#39;,
    hasCar: true,
    zipcode: null
};</code></pre>
<p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p>
<pre><code class="javascript">person.name; // &#39;Bob&#39;
person.zipcode; // null</code></pre>
<h2 id="strict-模式"><a href="#strict-模式" class="headerlink" title="strict 模式"></a>strict 模式</h2><p>如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量：</p>
<pre><code class="javascript">i = 10; // i现在是全局变量</code></pre>
<p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<pre><code class="javascript">&#39;use strict&#39;;</code></pre>
<p>不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串就是用 <code>&#39;&#39;</code> 或 <code>&quot;&quot;</code> 括起来的字符表示。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如 <code>&quot;I&#39;m OK&quot;</code> 包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</p>
<p>可转义 ASCII 字符和 Unicode 字符：</p>
<pre><code class="javascript">&#39;\x41&#39;; // ASCII 完全等同于 &#39;A&#39;
&#39;\u4e2d\u6587&#39;; // Unicode 完全等同于 &#39;中文&#39;</code></pre>
<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 <em>`\</em> … *`* 表示：</p>
<pre><code class="javascript">`这是一个
多行
字符串`;</code></pre>
<p><em>注意：反引号在键盘的ESC下方，数字键1的左边：</em></p>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>要把多个字符串连接起来，可以用 <code>+</code> 号连接</p>
<p>如果有很多变量需要连接，用 <code>+</code> 号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<pre><code class="javascript">var name = &#39;小明&#39;;
var age = 20;
var message = `你好, ${name}, 你今年${age}岁了!`;
alert(message);</code></pre>
<h2 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h2><h3 id="先重点说两个"><a href="#先重点说两个" class="headerlink" title="先重点说两个"></a>先重点说两个</h3><p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始，超出范围的索引不会报错，但一律返回undefined</p>
<pre><code class="javascript">var s = &#39;Hello, world!&#39;;

s[0]; // &#39;H&#39;
s[6]; // &#39; &#39;
s[7]; // &#39;w&#39;
s[12]; // &#39;!&#39;
s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined</code></pre>
<p><strong>需要特别注意的是，字符串是不可变的</strong>，如果对字符串的某个索引赋值，<strong>不会有任何错误，但是，也没有任何效果</strong>：</p>
<pre><code class="javascript">var s = &#39;Test&#39;;
s[0] = &#39;X&#39;;
alert(s); // s仍然为&#39;Test&#39;</code></pre>
<p>JavaScript为字符串提供了一些常用方法，<strong>注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串</strong></p>
<h3 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h3><p><code>toUpperCase()</code>把一个字符串全部变为大写：</p>
<pre><code class="javascript">var s = &#39;Hello&#39;;
s.toUpperCase(); // 返回&#39;HELLO&#39;</code></pre>
<h3 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h3><p><code>toLowerCase()</code>把一个字符串全部变为小写：</p>
<pre><code class="javascript">var s = &#39;Hello&#39;;
var lower = s.toLowerCase(); // 返回&#39;hello&#39;并赋值给变量lower
lower; // &#39;hello&#39;</code></pre>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p><code>indexOf()</code>会搜索指定字符串出现的位置：</p>
<pre><code class="javascript">var s = &#39;hello, world&#39;;
s.indexOf(&#39;world&#39;); // 返回7
s.indexOf(&#39;World&#39;); // 没有找到指定的子串，返回-1</code></pre>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p><code>substring()</code>返回指定索引区间的子串：</p>
<pre><code class="javascript">var s = &#39;hello, world&#39;
s.substring(0, 5); // 从索引0开始到5（不包括5），返回&#39;hello&#39;
s.substring(7); // 从索引7开始到结束，返回&#39;world&#39;</code></pre>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>JavaScript的 <code>Array</code> 可以包含任意数据类型，并通过索引来访问每个元素。要取得<code>Array</code>的长度，直接访问<code>length</code>属性。<strong>注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化</p>
<pre><code class="javascript">var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]</code></pre>
<p><code>Array</code>可以通过索引把对应的元素修改为新的值，因此，对<code>Array</code>的索引进行赋值会直接修改这个<code>Array</code>，<strong>注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化**</p>
<pre><code class="javascript">var arr = [1, 2, 3];
arr[5] = &#39;x&#39;;
arr; // arr变为[1, 2, 3, undefined, undefined, &#39;x&#39;]</code></pre>
<p>在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。</p>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>，左闭右开。如果不传参数的话，则会切整个数组，利用这个可以进行复制</p>
<pre><code class="javascript">var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];
var aCopy = arr.slice();
aCopy; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]
aCopy === arr; // false</code></pre>
<p>（为什么上面会返回 false ）</p>
<h2 id="unshift和shift"><a href="#unshift和shift" class="headerlink" title="unshift和shift"></a>unshift和shift</h2><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p>
<pre><code class="javascript">var arr = [1, 2];
arr.unshift(&#39;A&#39;, &#39;B&#39;); // 返回Array新的长度: 4
arr; // [&#39;A&#39;, &#39;B&#39;, 1, 2]
arr.shift(); // &#39;A&#39;
arr; // [&#39;B&#39;, 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
arr; // []</code></pre>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>
<pre><code class="javascript">var arr = [&#39;B&#39;, &#39;C&#39;, &#39;A&#39;];
arr.sort();
arr; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre>
<p>（还有个 reverse就不说了，sort 后续还会说）</p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<pre><code class="javascript">var arr = [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); // 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]
// 只删除,不添加:
arr.splice(2, 2); // [&#39;Google&#39;, &#39;Facebook&#39;]
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]
// 只添加,不删除:
arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); // 返回[],因为没有删除任何元素
arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</code></pre>
<p>第一个参数是起始位置，第二个参数是从起始位置开始要删除的元素个数，后续就是从起始位置开始要添加的元素</p>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>，<strong>注意</strong>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p>
<p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p>
<pre><code class="javascript">var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
arr.concat(1, 2, [3, 4]); // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, 4]</code></pre>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<pre><code class="javascript">var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3];
arr.join(&#39;-&#39;); // &#39;A-B-C-1-2-3&#39;</code></pre>
<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>
<h1 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h1><p>JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>JavaScript用一个<code>{...}</code>表示一个对象，键值对以<code>xxx: xxx</code>形式申明，用<code>,</code>隔开。注意，最后一个键值对不需要在末尾加<code>,</code>，如果加了，有的浏览器（如低版本的IE）将报错。</p>
<h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>&#39;&#39;</code>括起来：</p>
<pre><code class="javascript">var xiaohong = {
    name: &#39;小红&#39;,
    &#39;middle-school&#39;: &#39;No.1 Middle School&#39;
};</code></pre>
<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p>
<pre><code class="javascript">xiaohong[&#39;middle-school&#39;]; // &#39;No.1 Middle School&#39;
xiaohong[&#39;name&#39;]; // &#39;小红&#39;
xiaohong.name; // &#39;小红&#39;</code></pre>
<p>JavaScript规定，访问不存在的属性不报错，而是返回<code>undefined</code></p>
<h2 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h2><p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性</p>
<pre><code class="javascript">var xiaoming = {
    name: &#39;小明&#39;
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming[&#39;name&#39;]; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错</code></pre>
<h2 id="检查属性"><a href="#检查属性" class="headerlink" title="检查属性"></a>检查属性</h2><p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<pre><code class="javascript">var xiaoming = {
    name: &#39;小明&#39;,
    birth: 1990,
    school: &#39;No.1 Middle School&#39;,
    height: 1.70,
    weight: 65,
    score: null
};
&#39;name&#39; in xiaoming; // true
&#39;grade&#39; in xiaoming; // false</code></pre>
<p><strong>注意</strong>，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的</p>
<pre><code>&#39;toString&#39; in xiaoming; // true</code></pre><p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<pre><code class="javascript">var xiaoming = {
    name: &#39;小明&#39;
};
xiaoming.hasOwnProperty(&#39;name&#39;); // true
xiaoming.hasOwnProperty(&#39;toString&#39;); // false</code></pre>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p>
<pre><code class="javascript">var o = {
    name: &#39;Jack&#39;,
    age: 20,
    city: &#39;Beijing&#39;
};
for (var key in o) {
    console.log(key); // &#39;name&#39;, &#39;age&#39;, &#39;city&#39;
}</code></pre>
<p>要过滤掉对象继承的属性，用<code>hasOwnProperty()</code>来实现：</p>
<pre><code class="javascript">var o = {
    name: &#39;Jack&#39;,
    age: 20,
    city: &#39;Beijing&#39;
};
for (var key in o) {
    if (o.hasOwnProperty(key)) {
        console.log(key); // &#39;name&#39;, &#39;age&#39;, &#39;city&#39;
    }
}</code></pre>
<p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p>
<pre><code class="javascript">var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
for (var i in a) {
    console.log(i); // &#39;0&#39;, &#39;1&#39;, &#39;2&#39;
    console.log(a[i]); // &#39;A&#39;, &#39;B&#39;, &#39;C&#39;
}</code></pre>
<p><strong>注意</strong>，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>这个循环可以直接拿到元素本身，和 Java 里 enhanced for loop 是一样的。ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p>
<pre><code class="javascript">var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
var s = new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);
var m = new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + &#39;=&#39; + x[1]);
}</code></pre>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。</p>
<pre><code class="javascript">// 二维数组:
// var m = new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]);
var m = new Map(); // 空Map
m.set(&#39;Adam&#39;, 67); // 添加新的key-value
m.set(&#39;Bob&#39;, 59);
m.has(&#39;Adam&#39;); // 是否存在key &#39;Adam&#39;: true
m.get(&#39;Adam&#39;); // 67
m.delete(&#39;Adam&#39;); // 删除key &#39;Adam&#39;
m.get(&#39;Adam&#39;); // undefined</code></pre>
<p>(Set 省略)</p>
<p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
<p>Map 的 iterator 获取：</p>
<pre><code class="javascript">var iterator = map.entries();
console.log(iteratir.next());</code></pre>
<h1 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h1><p><code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个<code>Array</code>数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p>
<p>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<pre><code class="javascript">var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
a.name = &#39;Hello&#39;;
for (var x in a) {
    console.log(x); // &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;name&#39;
}</code></pre>
<p><code>for ... in</code>循环将把<code>name</code>包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。</p>
<p><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<pre><code class="javascript">var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];
a.name = &#39;Hello&#39;;
for (var x of a) {
    console.log(x); // &#39;A&#39;, &#39;B&#39;, &#39;C&#39;
}</code></pre>
<p>这就是为什么要引入新的<code>for ... of</code>循环。</p>
<p>更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。</p>
<pre><code class="javascript">// 廖雪峰教程中书写方式
a.forEach(function (element, index, array) {
    console.log(element + &quot;, index = &quot; + index);
});
// VSCode 自动生成的格式，这个array声明集合类型的
a.forEach((element, index(,array) =&gt; {
    console.log(element + index);
});</code></pre>
<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身</p>
<pre><code class="javascript">var s = new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);
s.forEach(function (element, sameElement, set) {
    console.log(element);
});</code></pre>
<p><code>Map</code>的回调函数参数依次为<code>value</code>、<code>key</code>和<code>map</code>本身：</p>
<pre><code class="javascript">var m = new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);
m.forEach(function (value, key, map) {
    console.log(value);
});</code></pre>
<h1 id="导入导出模块"><a href="#导入导出模块" class="headerlink" title="导入导出模块"></a>导入导出模块</h1><p>导出模块使用 <code>export</code> 关键字：</p>
<pre><code class="javascript">export function formatDate(date) {
    return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
}</code></pre>
<p>导入之前，需要在 HTML 的 script 标签中，添加 type 属性，值为 module：</p>
<pre><code class="html">&lt;script src=&quot;main.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code></pre>
<pre><code class="javascript">import { formatDate } from &quot;./myjs.js&quot;;
console.log(formatDate(new Date()));</code></pre>
<p>在导出的时候，可以把 export 写在最后面，然后用大括号包起来，一起导出。</p>
<p>导入导出还有另外一个写法：</p>
<pre><code class="javascript">// 导出的情况 my.js
module.exports = {
    mod1, 
    mod2,
    ...
};</code></pre>
<pre><code class="javascript">// 导入的情况 main.js
const {mod1, mod2, ...} = require(./my.js);</code></pre>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>函数本身也是一个对象！</strong></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>方法 1：</p>
<pre><code class="javascript">function 函数名(参数) {
    ...
}</code></pre>
<p>这个函数名，可以理解成对这个函数对象的引用，和 Java 里的引用一个意思。</p>
<p>方法 2：</p>
<pre><code class="javascript">var 函数名 = function(参数) {
    ...
}</code></pre>
<p><strong>上述两种定义<em>完全等价</em>，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</strong></p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</p>
<pre><code class="javascript">abs(10, &#39;blablabla&#39;); // 返回10
abs(-9, &#39;haha&#39;, &#39;hehe&#39;, null); // 返回9</code></pre>
<p>传入的参数比定义的少也没有问题：</p>
<pre><code class="javascript">abs(); // 返回NaN</code></pre>
<p>此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。</p>
<p>要避免收到<code>undefined</code>，可以对参数进行检查：</p>
<pre><code class="javascript">function abs(x) {
    if (typeof x !== &#39;number&#39;) {
        throw &#39;Not a number&#39;;
    }
    if (x &gt;= 0) {
        return x;
    } else {
        return -x;
    }
}</code></pre>
<h2 id="Arguments-和-Rest"><a href="#Arguments-和-Rest" class="headerlink" title="Arguments 和 Rest"></a>Arguments 和 Rest</h2><p>在 JS 里，默认集成了叫 <code>arguments</code> 的东西，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似 <code>Array</code> 但它不是一个 <code>Array</code></p>
<pre><code class="javascript">function foo(x) {
    console.log(&#39;x = &#39; + x); // 10
    for (var i=0; i&lt;arguments.length; i++) {
        console.log(&#39;arg &#39; + i + &#39; = &#39; + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);</code></pre>
<p>上面规定了只拿一个参数来做处理，那后面的并不是完全忽略了，其传进来的值都会存到 <code>arguments</code> 里。<strong>所以说，就算是函数本身不定义传参的多少，也是可以拿到实际传进来的所有参数的！</strong>实际上 <code>arguments</code> 最常用于判断传入参数的个数。</p>
<p>对应 <code>arguments</code> ，还有一个叫 <code>rest</code> 的</p>
<blockquote>
<p>ES6标准引入了rest参数</p>
</blockquote>
<p>这个 <code>rest</code> 只会把多余的传进来的参数打包放在这里面，和 argument 非常相似。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>JS 中，用<code>var</code>申明的变量实际上是有作用域的。基本上原则和 Java 类似，由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：</p>
<pre><code class="javascript">use strict&#39;;

function foo() {
    var x = 1;
    function bar() {
        var y = x + 1; // bar可以访问foo的变量x!
    }
    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
}</code></pre>
<p>出现重名的情况，就是就近原则，或者说是自己访问自己领域中的。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</p>
<pre><code class="javascript">&#39;use strict&#39;;

function foo() {
    var x = &#39;Hello, &#39; + y;
    console.log(x);
    var y = &#39;Bob&#39;;
}

foo();</code></pre>
<p>虽然是strict模式，但语句<code>var x = &#39;Hello, &#39; + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>console.log</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。</p>
<p><strong>这块说人话就是，JS 会先把一个 function 中的所有变量找出来进行声明，但是不赋值，然后按顺序编译。</strong></p>
<p>我们在函数内部定义变量时，请严格遵守 <strong>“在函数内部首先申明所有变量”</strong> 这一规则。最常见的做法是用一个<code>var</code>申明函数内部用到的所有变量：</p>
<pre><code class="javascript">function foo() {
    var
        x = 1, // x初始化为1
        y = x + 1, // y初始化为2
        z, i; // z和i为undefined
    // 其他语句:
    for (i=0; i&lt;100; i++) {
        ...
    }
}</code></pre>
<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>JS 这面有点意思，所有最高层级的变量，包括函数，都会被存放在一个叫 <code>window</code> 的变量中，如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报 <code>ReferenceError</code> 错误。</p>
<pre><code class="javascript">&#39;use strict&#39;;

function foo() {
    alert(&#39;foo&#39;);
}

foo(); // 直接调用foo()
window.foo(); // 通过window.foo()调用</code></pre>
<h2 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h2><p>全局变量会绑定到 <code>window</code> 上，<strong>不同的JavaScript文件</strong>如果使用了<strong>相同的全局变量</strong>，或者<strong>定义了相同名字的顶层函数</strong>，都会造成<strong>命名冲突</strong>，并且很难被发现。</p>
<p>减少冲突的一个方法是<strong>把自己的所有变量和函数全部绑定到一个全局变量中</strong>。例如：</p>
<pre><code class="javascript">// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = &#39;myapp&#39;;
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return &#39;foo&#39;;
};</code></pre>
<p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>
<h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><p>JS 里如果在 for 循环里用 var 声明了一个变量，即使循环结束，这个变量也依然存在于<strong>当前的函数内</strong>，所以为了解决块级作用域，ES6引入了新的关键字 <code>let</code> ，用 <code>let</code> 替代 <code>var</code> 可以申明一个块级作用域的变量。</p>
<pre><code class="javascript">&#39;use strict&#39;;

function foo() {
    var sum = 0;
    for (let i=0; i&lt;100; i++) {
        sum += i;
    }
    // SyntaxError:
    i += 1;
}</code></pre>
<p>个人见解：其 var 的声明方式很宽泛，只要在一个 “函数” 内，无论在哪里他都是有效的，因为这些变量都会集体存放在一个 “地方”。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值：</p>
<pre><code class="javascript">var PI = 3.14;</code></pre>
<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：</p>
<pre><code class="javascript">&#39;use strict&#39;;

const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
// Uncaught TypeError: Assignment to constant variable.
PI; // 3.14</code></pre>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>在ES6中，可以使用解构赋值，直接对多个变量同时赋值：</p>
<pre><code class="javascript">var [x, y, z] = [&#39;hello&#39;, &#39;JavaScript&#39;, &#39;ES6&#39;];  // 如果 x 和 y 为空，则只给 z 赋值</code></pre>
<p>以上就对 x，y，和 z 同时进行赋值，对数组元素进行解构赋值的时候，格式要一一对应</p>
<pre><code class="javascript">let [x, [y, z]] = [&#39;hello&#39;, [&#39;JavaScript&#39;, &#39;ES6&#39;]];
x; // &#39;hello&#39;
y; // &#39;JavaScript&#39;
z; // &#39;ES6&#39;</code></pre>
<p>利用这个特点，可以直接从一个对象中取出若干属性</p>
<pre><code class="javascript">&#39;use strict&#39;;

var person = {
    name: &#39;小明&#39;,
    age: 20,
    gender: &#39;male&#39;,
    passport: &#39;G-12345678&#39;,
    school: &#39;No.4 middle school&#39;
};
var {name:nickname, age, passport} = person;
// 当属性名和变量名不一样的时候，可以用上面的冒号进行赋值</code></pre>
<p>对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的:</p>
<pre><code class="javascript">var person = {
    name: &#39;小明&#39;,
    age: 20,
    gender: &#39;male&#39;,
    passport: &#39;G-12345678&#39;,
    school: &#39;No.4 middle school&#39;,
    address: {
        city: &#39;Beijing&#39;,
        street: &#39;No.1 Road&#39;,
        zipcode: &#39;100001&#39;
    }
};
var {name, address: {city, zip}} = person;
name; // &#39;小明&#39;
city; // &#39;Beijing&#39;
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined</code></pre>
<p>解构的时候，可以给一个默认值，防止对象中没有该属性，null 会覆盖默认值，在 JS 中是一个 “值”</p>
<p>注意事项：</p>
<p>如果变量名在提前已经声明了，那么在进行解构赋值的时候，注意要再代码的最两端加上小括号，这是因为JavaScript引擎把<code>{</code>开头的语句当作了块处理，于是<code>=</code>不再合法。</p>
<pre><code class="javascript">// 声明变量:
var x, y;
// 解构赋值:
{x, y} = { name: &#39;小明&#39;, x: 100, y: 200};
// 语法错误: Uncaught SyntaxError: Unexpected token =</code></pre>
<h2 id="rest操作符"><a href="#rest操作符" class="headerlink" title="rest操作符"></a>rest操作符</h2><p>rest 操作符为三个点 <code>...</code> ，其表示没有被解构到剩余的元素，会以一个数组的形式返回</p>
<pre><code class="javascript">var arr = [1, 2, 3, 4, 5, 6, 7];
var [a, b, ...rest] = arr;
console.log(a, b, rest);</code></pre>
<p>在 <code>...</code> 之后需要给个剩余元素数组一个名字</p>
<p>对于对象来说，rest 会获取到其他的剩余的元素，而不像数组只会获取到后面的元素。</p>
<pre><code class="javascript">const post = {
    id: 2,
    title: &quot;Hello!Java!&quot;,
    cotent: &quot;123456&quot;,
    comments: [
        {
            userId: 1,
            comment: &quot;Comment 1&quot;
        },{
            userId: 2,
            comment: &quot;Comment 2&quot;
        },{
            userId: 3,
            comment: &quot;Comment 3&quot;
        }
    ]
}

var { comments, ...rest} = post;  // 这里的 rest 包含 id, title, 和 content</code></pre>
<p>通过 rest 结构还可以巧妙的获取到特定的参数：</p>
<pre><code class="javascript">function savePostObj({ id, title, content, ... rest}) {
    console.log(&quot;保存了文章 &quot;, id, title, content);
    console.log(rest);
}</code></pre>
<h2 id="spread操作符"><a href="#spread操作符" class="headerlink" title="spread操作符"></a>spread操作符</h2><p>这个和 rest 虽然长得很像都是三个点，但是概念刚好相反，spread 是取所有，<strong>并逐一分配</strong>，多用于克隆一整个对象</p>
<pre><code class="javascript">var post = {
    id: 1,
    title: &quot;Title 1&quot;,
    content: &quot;content&quot;
};

var postClone = { ...post };
console.log(post === postClone);  // false</code></pre>
<p>这样克隆出来的是一个新的对象，地址和之前的不一样，同时利用 spread 可以在原有的基础上进行添加：</p>
<pre><code class="javascript">var post2 = {
    ...post, 
    author: &quot;BlackKnife&quot;
};</code></pre>
<p>数组也是适用的！</p>
<h2 id="解构赋值使用场景"><a href="#解构赋值使用场景" class="headerlink" title="解构赋值使用场景"></a>解构赋值使用场景</h2><p>解构赋值在很多时候可以大大简化代码。例如，交换两个变量<code>x</code>和<code>y</code>的值，可以这么写，不再需要临时变量：</p>
<pre><code class="javascript">var x=1, y=2;
[x, y] = [y, x]</code></pre>
<p>快速获取当前页面的域名和路径：</p>
<pre><code class="javascript">var {hostname:domain, pathname:path} = location;</code></pre>
<p>如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个<code>Date</code>对象：</p>
<pre><code class="javascript">function buildDate({year, month, day, hour=0, minute=0, second=0}) {
    return new Date(year + &#39;-&#39; + month + &#39;-&#39; + day + &#39; &#39; + hour + &#39;:&#39; + minute + &#39;:&#39; + second);
}</code></pre>
<p>它的方便之处在于传入的对象只需要<code>year</code>、<code>month</code>和<code>day</code>这三个属性：</p>
<pre><code class="javascript">buildDate({ year: 2017, month: 1, day: 1 });
// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)
// 传入情况：
// {year, month, day, hour=0, minute=0, second=0} = { year: 2017, month: 1, day: 1 }</code></pre>
<p>也可以传入<code>hour</code>、<code>minute</code>和<code>second</code>属性：</p>
<pre><code class="javascript">buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 });
// Sun Jan 01 2017 20:15:00 GMT+0800 (CST)</code></pre>
<p>使用解构赋值可以减少代码量，但是，<strong>需要在支持ES6解构赋值特性的现代浏览器中才能正常运行</strong>。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>绑定到对象上的函数称为方法，<strong>这个方法可以写在对象外，也可以写在对象内！</strong></p>
<pre><code class="javascript">var xiaoming = {
    name: &#39;小明&#39;,
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了</code></pre>
<p>上面 <code>xiaoming.age</code> 返回的只是这个 function 本身，而 <code>xiaoming.age()</code> 才是真正的调用了该函数。<strong>特别特别注意一点！</strong> 这个 <code>this</code> 是个其调用者绑定的！这个 <code>this</code> 是个其调用者绑定的！这个 <code>this</code> 是个其调用者绑定的！首先上面这个代码是可以拆开写的：</p>
<pre><code class="javascript">function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: &#39;小明&#39;,
    birth: 1990,
    age: getAge
};

console.log(xiaoming.age()) // 25, 正常结果
getAge(); // NaN 或者直接报错</code></pre>
<p>这里，<code>xiaoming.age()</code> 的调用者是 <code>xiaoming</code> ，那么这个 <code>this</code> 也就是指向的是 <code>xiaoming</code> 本身，才能获取到需要的属性值；而下面直接调用 <code>getAge()</code> 的话，其实际的调用者为 <code>window</code> ！切记！这个 <code>this</code> 是跟着调用者走的！</p>
<h2 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call"></a>apply和call</h2><p>这个 apply 可以在某种程度上解决上面的 “方法” 带来的种种缺陷，它接收两个参数，第一个参数就是需要绑定的 <code>this</code>变量，第二个参数是 <code>Array</code>，表示函数本身的参数。</p>
<pre><code class="javascript">function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: &#39;小明&#39;,
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空，getAge() 本身没参数，所以不写

var fn = xiaoming.age;
console.log(fn.apply(xiaoming, []))  // 这样也是可以的</code></pre>
<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>
<li><code>call()</code>把参数按顺序传入。</li>
</ul>
<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：</p>
<pre><code class="javascript">Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5</code></pre>
<p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
<p>还有一个 <code>bind</code> 用法和 <code>call</code> 一样只是它会返回一个闭包，不会马上执行。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。这里个人绝对就是对某个函数的重写再封装，先获取到原函数对象，然后改写。</p>
<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：</p>
<pre><code class="javascript">&#39;use strict&#39;; 

var count = 0; 
var oldParseInt = parseInt; // 保存原函数 

window.parseInt = function () {    
    count += 1;    
    return oldParseInt.apply(null, arguments); // 调用原函数 
};</code></pre>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>所谓高阶函数，就是把一个 function 当做参数传给另一个方法，然后在其内部进行调用：</p>
<pre><code class="javascript">function add(x, y, f) {
    return f(x) + f(y);
}</code></pre>
<p>当我们调用 <code>add(-5, 6, Math.abs)</code> 时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和函数<code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：</p>
<pre><code class="javascript">x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;
return 11;</code></pre>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>JS 里的 map 和我想的 map 不太一样，它更多的是起到一个<strong>批量统一处理</strong>的作用，可以用一个数组来调用 map() 函数，然后在函数里传一个想进行操作的函数。</p>
<pre><code class="javascript">&#39;use strict&#39;;

function pow(x) {
    return x * x;
}

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
console.log(results);
</code></pre>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>这东西，也是 array 里有的一方法，需要往里传入一个 function，这个 function 必须有两个参数。作用呢，是需对这个数组里所有的元素进行一个操作，一个接着一个，且结果累加：</p>
<p>这里的 x 为上一次的结果，y 为当前元素</p>
<pre><code class="javascript">&#39;use strict&#39;;

function foo(x, y) {
    return x * y;
}
var arr = [1, 3, 5, 7, 9];

console.log(arr.reduce(foo));
</code></pre>
<p>上面这个 reduce，首先是把 1 * 3 的乘在一起，然后这个结果继续和下一个相乘，直到结尾。</p>
<h2 id="map-reduce-小案例"><a href="#map-reduce-小案例" class="headerlink" title="map + reduce 小案例"></a>map + reduce 小案例</h2><p>把一个数字字符串转换成数字，写一个 string2int 的function：</p>
<pre><code class="javascript">&#39;use strict&#39;;

function string2int(s) {
        return s.split(&quot;&quot;)
            .map(function(x) { return x - 0; })
            .reduce(function (x, y) { return x * 10 + y; });
}</code></pre>
<p>把一个字符串格式的数字转换成整数的形式，可以用 <code>parseInt</code>，<code>Number</code> 和 字符串减0</p>
<p>请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：<code>[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]</code>，输出：<code>[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]</code></p>
<pre><code class="javascript">function normalize(arr) {
    for (let i = 0; i &lt; arr.length; i++) {
        var temp = arr[i].toLowerCase().split(&quot;&quot;);
        temp[0] = temp[0].toUpperCase();
        arr[i] = temp.reduce(function (x, y) {
            return x.concat(y);
        })
    }
    return arr;
}</code></pre>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>和<code>map()</code>类似，<code>Array</code>的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>
<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：</p>
<pre><code class="javascript">var arr = [1, 2, 4, 5, 6, 9, 10, 15];
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]</code></pre>
<p>用 filter 巧妙去重：</p>
<pre><code class="javascript">&#39;use strict&#39;;

var r,
    arr = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;strawberry&#39;];

r = arr.filter(function (element, index, self) {
    return self.indexOf(element) === index;
});
</code></pre>
<h2 id="sort-1"><a href="#sort-1" class="headerlink" title="sort"></a>sort</h2><p>JS 里的 Array 自己的 sort()  方法，是先把内容转换成字符串然后在进行比较的！！真是天坑！！所以说，这个 sort 可以往里传入一个自己写的排序函数，来重写他的排序规则</p>
<pre><code class="javascript">&#39;use strict&#39;;

var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x &lt; y) {
        return -1;
    }
    if (x &gt; y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]</code></pre>
<p>如果按照字符串的先后顺序进行比较的话，可以先把他们全都变成小写的，然后在进行比较。</p>
<p>另外注意一点就是，<strong>sort 会对原数组进行修改！</strong></p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>对于数组，除了<code>map()</code>、<code>reduce</code>、<code>filter()</code>、<code>sort()</code>这些方法可以传入一个函数外，<code>Array</code>对象还提供了很多非常实用的高阶函数。</p>
<p><code>every()</code>方法可以判断数组的所有元素是否满足测试条件，比如下面的例子：</p>
<pre><code class="javascript">&#39;use strict&#39;;
var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];
console.log(arr.every(function (s) {
    return s.length &gt; 0;
})); // true, 因为每个元素都满足s.length&gt;0

console.log(arr.every(function (s) {
    return s.toLowerCase() === s;
})); // false, 因为不是每个元素都全部是小写
</code></pre>
<p><code>find()</code>方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回<code>undefined</code>：</p>
<pre><code class="javascript">&#39;use strict&#39;;
var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];
console.log(arr.find(function (s) {
    return s.toLowerCase() === s;
})); // &#39;pear&#39;, 因为pear全部是小写

console.log(arr.find(function (s) {
    return s.toUpperCase() === s;
})); // undefined, 因为没有全部是大写的元素</code></pre>
<p><code>findIndex()</code>和<code>find()</code>类似，也是查找符合条件的第一个元素，不同之处在于<code>findIndex()</code>会返回这个元素的索引，如果没有找到，返回<code>-1</code></p>
<p><code>forEach()</code>和<code>map()</code>类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。<code>forEach()</code>常用于遍历数组，因此，传入的函数不需要返回值</p>
<p>还有 <code>some</code> 方法…等等</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包这块，个人感觉，是把一个参数丢进去之后，先不通过内部存在的函数马上获取到结果，而是把这个参数与这个内部存在的函数绑定在一起，返回成一个类似于对象的东西？等需要的时候，再执行，不过这里面有一些坑：</p>
<pre><code class="javascript">function count() {
    var arr = [];
    for (var i=1; i&lt;=3; i++) {
        arr.push(function () {
            return i * i;
        });
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];</code></pre>
<p>这里，f1，f2，和 f3 存的那个闭包对象里的那个 i，其实都是同一个 i，因为退出循环最后这个 i 是4，所以他们的结果都是 16，所以返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。</p>
<p>如果非要这么做的话，可以采用匿名函数的形式来解决：</p>
<pre><code class="javascript">function count() {
    var arr = [];
    for (var i=1; i&lt;=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}</code></pre>
<p>“创建一个匿名函数并立刻执行”的语法：</p>
<pre><code class="javascript">(function (x) {
    return x * x;
})(3); // 9</code></pre>
<p>理论上讲，创建一个匿名函数并立刻执行可以这么写：</p>
<pre><code class="javascript">function (x) { return x * x } (3);</code></pre>
<p>但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：</p>
<pre><code class="javascript">(function (x) { return x * x }) (3);</code></pre>
<p>在没有<code>class</code>机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器</p>
<pre><code class="javascript">&#39;use strict&#39;;

function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}</code></pre>
<p>它用起来像这样：</p>
<pre><code class="javascript">var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13</code></pre>
<p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算x^y可以用<code>Math.pow(x, y)</code>函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数<code>pow2</code>和<code>pow3</code>：</p>
<pre><code class="javascript">&#39;use strict&#39;;
function make_pow(n) {
    return function (x) {
        return Math.pow(x, n);
    }
}</code></pre>
<h2 id="闭包的脑洞"><a href="#闭包的脑洞" class="headerlink" title="闭包的脑洞"></a>闭包的脑洞</h2><p>这块就不详细展开说了，自己写了一个简易版的</p>
<pre><code class="javascript">&#39;use strict&#39;;
// a 代表 1
var a = function (f) {
    return function () {
        return f();
    }
}
// 相加操作，相当于在做一层层的嵌套
function add(m, n) {
    return function (f) {
        // 这一层加上去的目的是保持闭包，同时它能作为一个 function 来作参数
        // 这里这一步是核心所在
        return function () {
            // 形成多层嵌套
            return m(f)(n(f)());
        }
    }
}
// 得到 2
var b = add(a, a);
// 得到 3
var c = add(a, b);
var five = add(b, c);

// 打印 5 次
five(function () { console.log(&quot;5&quot;); })(); 

</code></pre>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p><strong>ES6 标准</strong>新增了一种新的函数：Arrow Function（箭头函数）。</p>
<pre><code>x =&gt; x * x</code></pre><p>如果参数不是一个，就需要用括号<code>()</code>括起来：</p>
<pre><code class="javascript">// 两个参数:
(x, y) =&gt; x * x + y * y

// 无参数:
() =&gt; 3.14

// 可变参数:
(x, y, ...rest) =&gt; {
    var i, sum = x + y;
    for (i=0; i&lt;rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}</code></pre>
<p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p>
<pre><code class="javascript">// SyntaxError:
x =&gt; { foo: x }</code></pre>
<p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：</p>
<pre><code class="javascript">// ok:
x =&gt; ({ foo: x })</code></pre>
<h1 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h1><p>generator 就是字面义，一个生产者，每次调用这个对象里的某个函数，就可以得到一次次的结果。其本身有点像可以多次返回的函数，通过调用 <code>next()</code> 来获取到下一轮结果。它的命名方式和 function 和相似，需要在后面加一个 <code>*</code> </p>
<pre><code class="javascript">function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 0;
    while (n &lt; max) {
        yield a;
        [a, b] = [b, a + b];
        n ++;
    }
    return;
}</code></pre>
<p>个人觉得它的实现也是在某种程度上使用的闭包：</p>
<pre><code class="javascript">var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}</code></pre>
<p>这里获得的是 generator 对象，然后里面的变量都会存在着里面，随着 while 里一次次 yield 来实现类似暂停判断的效果，然后返回 yield 时想要的值。调用 <code>next()</code> 获取到的是一个数组，里面存了 value 和 done 属性。</p>
<p>generator对象本身，好像也是一个数组… 可以通过 <code>for ... of</code> 来获取到里面的内容：</p>
<pre><code class="javascript">for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}</code></pre>
<p>在JavaScript的世界里，一切都是对象。</p>
<p>但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用 <code>typeof</code> 操作符获取对象的类型，它总是返回一个字符串：</p>
<pre><code class="javascript">typeof 123; // &#39;number&#39;
typeof NaN; // &#39;number&#39;
typeof &#39;str&#39;; // &#39;string&#39;
typeof true; // &#39;boolean&#39;
typeof undefined; // &#39;undefined&#39;
typeof Math.abs; // &#39;function&#39;
typeof null; // &#39;object&#39;
typeof []; // &#39;object&#39;
typeof {}; // &#39;object&#39;</code></pre>
<h1 id="对象-2"><a href="#对象-2" class="headerlink" title="对象"></a>对象</h1><h2 id="包装（装箱）"><a href="#包装（装箱）" class="headerlink" title="包装（装箱）"></a>包装（装箱）</h2><p>JS 里有和 Java 类似的有一个装箱，<code>number</code>、<code>boolean</code>和 <code>string</code> 都有包装对象</p>
<pre><code class="javascript">var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String(&#39;str&#39;); // &#39;str&#39;,生成了新的包装类型

typeof new Number(123); // &#39;object&#39;
new Number(123) === 123; // false

...</code></pre>
<p>虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为<code>object</code>了！所以，包装对象和原始值用<code>===</code>比较会返回 <code>false</code></p>
<p>如果不写 new 的话，其本身只是对应的 <code>number</code>、<code>boolean</code> 和 <code>string</code> 类型</p>
<pre><code class="javascript">var n = Number(&#39;123&#39;); // 123，相当于parseInt()或parseFloat()
typeof n; // &#39;number&#39;</code></pre>
<p>个人认为，上面这个 <code>Number()</code> 其本身只是起类型转换的作用，而不是其创建某个类型对象的作用</p>
<p>有这么几条规则需要遵守：</p>
<ul>
<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>
<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>
<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>
<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>
<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>
<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>
<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>
<li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li>
</ul>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>
<pre><code class="javascript">var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getTime(); // 1435146562875, 以number形式表示的时间戳
...</code></pre>
<p> <strong>JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。所以要表示6月，我们传入的是<code>5</code>！</strong></p>
<p>创建 Date 对象两个方法：</p>
<pre><code class="javascript">var d = new Date(2015, 5, 19, 20, 15, 30, 123);
d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)

var d = Date.parse(&#39;2015-06-24T19:49:22.875+08:00&#39;);
d; // 1435146562875</code></pre>
<p>第二种返回的不是<code>Date</code>对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个<code>Date</code>：</p>
<pre><code class="javascript">var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
d.getMonth(); // 5</code></pre>
<p>时区问题不用考虑，只需要获取时间戳，JS 就会根据浏览器的本地的时区自动转换成当地时间：</p>
<pre><code class="javascript">if (Date.now) {
    console.log(Date.now()); // 老版本IE没有now()方法
} else {
    console.log(new Date().getTime());
}</code></pre>
<h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，<code>.</code>可以匹配任意字符，所以：</p>
<ul>
<li><code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；</li>
<li><code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code>；</li>
<li><code>&#39;js.&#39;</code>可以匹配<code>&#39;jsp&#39;</code>、<code>&#39;jss&#39;</code>、<code>&#39;js!&#39;</code>等等。</li>
</ul>
<p>用<code>*</code>表示任意个字符（包括0个）</p>
<p>用<code>+</code>表示至少一个字符</p>
<p>用<code>?</code>表示0个或1个字符</p>
<p>用<code>{n}</code>表示n个字符</p>
<p>用<code>{n,m}</code>表示n-m个字符：</p>
<ul>
<li><code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</li>
<li><code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</li>
</ul>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p>
<ul>
<li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li>
<li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;js2015&#39;</code>等等；</li>
<li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；</li>
<li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
</ul>
<p><code>A|B</code>可以匹配A或B，所以<code>(J|j)ava(S|s)cript</code>可以匹配<code>&#39;JavaScript&#39;</code>、<code>&#39;Javascript&#39;</code>、<code>&#39;javaScript&#39;</code>或者<code>&#39;javascript&#39;</code>。</p>
<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>
<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>
<p>这里要多写个个人注释：</p>
<p><code>^</code> 如果在正则中出现，则表示从输入的整个内容的最开始开始，<code>$</code> 则只规定了输入的整个内容的最后的部分，但是当他俩同时出现的时候，则是对一整段内容进行约束，当执行 exec() 的时候，它就会去整个内容的头和尾包括中间的部分去找，所以它不能用于全局搜索，比如：</p>
<pre><code class="javascript">var s = &#39;JavaScript, VBScript, JScript and ECMAScript&#39;;</code></pre>
<p>想把里面所有的 XXXScript 找出来，那么就不能用 <code>^...$</code> </p>
<pre><code class="javascript">var re=/^[a-zA-Z]+Script$/g;</code></pre>
<p>这个写法里，从 Java 开始 一直到 ECMA 都可以被看做是开头部分，这里面已经有空格和逗号了，所以这已经是一整段匹配不到，最后返回一个 null。正确写法是去掉 <code>^...$</code>，这样在搜的时候就是匹配到，在每次遇到完空格和标点之后开始去匹配。</p>
<p>JS 使用正则的格式</p>
<pre><code class="javascript">var re1 = /ABC\-001/;
var re2 = new RegExp(&#39;ABC\\-001&#39;);

var re = /^\d{3}\-\d{3,8}$/;
re.test(&#39;010-12345&#39;); // true
re.test(&#39;010-1234x&#39;); // false</code></pre>
<h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p>
<pre><code class="javascript">var re = /^(\d+)(0*)$/;
re.exec(&#39;102300&#39;); // [&#39;102300&#39;, &#39;102300&#39;, &#39;&#39;]</code></pre>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<pre><code class="javascript">var re = /^(\d+?)(0*)$/;
re.exec(&#39;102300&#39;); // [&#39;102300&#39;, &#39;1023&#39;, &#39;00&#39;]</code></pre>
<h3 id="验证邮箱"><a href="#验证邮箱" class="headerlink" title="验证邮箱"></a>验证邮箱</h3><p>一个简单的写法：</p>
<pre><code class="javascript">var re = /^\w{2,10}(\.(\w{2,20}))?\@\w+(\.\w+)$/;</code></pre>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是JavaScript Object Notation的缩写，它是一种<strong>数据交换格式</strong>。SON定死了字符集必须是<strong>UTF-8</strong>，表示多语言就没有问题了。为了统一解析，JSON的<strong>字符串规定必须用双引号</strong> <code>&quot;&quot;</code> ，<strong>Object的键也必须用双引号</strong> <code>&quot;&quot;</code>。</p>
<p>几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为<strong>JavaScript内置了JSON的解析</strong>。把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。</p>
<p>如果我们<strong>收到一个JSON格式的字符串</strong>，只需要把它<strong>反序列化成一个JavaScript对象</strong>，就可以在JavaScript中直接<strong>使用这个对象</strong>了。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code class="javascript">var s = JSON.stringify(object);</code></pre>
<p>要输出得好看一些，可以加上参数，按缩进输出：</p>
<pre><code class="javascript">var s = JSON.stringify(xiaoming, null, &quot;  &quot;);</code></pre>
<p>第二个参数可以传的有很多，比如可以传一个 Array 进去，里面填写想获得的 key 的名字：</p>
<pre><code class="javascript">var s =  JSON.stringify(xiaoming, [&quot;name&quot;, &quot;age&quot;], &quot;  &quot;);</code></pre>
<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：（下面是把所有属性值变大写）</p>
<pre><code class="javascript">function convert(key, value) {
    if (typeof value === &#39;string&#39;) {
        return value.toUpperCase();
    }
    return value;
}

var s = JSON.stringify(xiaoming, convert, &quot;  &quot;);</code></pre>
<p>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：</p>
<pre><code class="javascript">// 在 xiaoming 的对象里添加一个这样的方法
toJSON: function () {
    return { // 只输出name和age，并且改变了key：
        &#39;Name&#39;: this.name,
        &#39;Age&#39;: this.age
    };
}</code></pre>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：</p>
<pre><code class="javascript">JSON.parse(&#39;[1,2,3,true]&#39;); // [1, 2, 3, true]
JSON.parse(&#39;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14}&#39;); // Object {name: &#39;小明&#39;, age: 14}
JSON.parse(&#39;true&#39;); // true
JSON.parse(&#39;123.45&#39;); // 123.45</code></pre>
<p><code>JSON.parse()</code>还可以接收一个函数，作为第二个参数，用来转换解析出的属性：</p>
<h3 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h3><h2 id="对象-3"><a href="#对象-3" class="headerlink" title="对象"></a>对象</h2><p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是<strong>把一个对象的原型指向另一个对象</strong>而已。</p>
<p><img src="https://images-1259064069.cos.ap-guangzhou.myqcloud.com/images/l" alt="xiaoming-prototype"></p>
<p>在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型，并且，低版本的IE也无法使用<code>__proto__</code>。<code>Object.create()</code>方法可以传入一个原型对象，并创建一个基于该原型的新对象</p>
<pre><code class="javascript">var Person = {
    name: &quot;default&quot;,
    age: 0,
    run: function () {
        console.log(this.name + &quot;is running&quot;);
    },
    getAge: function () {
        return this.age;
    }
}

function creatPerson(name) {
    // 这个 p 其实感觉就是复制了一份 Person，然后自己手写这个方法来充当构造函数
    var person = Object.create(Person);
    person.name = name;
    return person;
}

var p = creatPerson(&quot;Jade&quot;);
p.run();
console.log(p.getAge());</code></pre>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建对象的方法有很多，可以通过大括号包含，然后键值对的方式来创建：</p>
<pre><code class="javascript">var person = {
    name: &quot;张三&quot;,
    age: 20,
    postion: &quot;前端工程师&quot;,
    signIn: function() {
        console.log(&quot;张三打卡&quot;);
    }
}</code></pre>
<p>也可以先通过 <code>new</code> 关键字，然后赋予属性值和方法：</p>
<pre><code class="javascript">var person = new Object();
person.name = &quot;Jobs&quot;;
person.signIn = function() {
    console.log(&quot;打卡&quot;);
}</code></pre>
<h3 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h3><p>可以通过 <code>Object.keys()</code> 这个方法来获取到一个键的数组：</p>
<pre><code class="javascript">var keyArr = Object.keys(person);</code></pre>
<p>也可以用 <code>for...in</code> 的方式来得到每一个键值</p>
<pre><code class="javascript">for (key in person) {
    console.log(key);
}</code></pre>
<p>删除一个属性直接用 <code>delete</code> 就可以</p>
<pre><code class="javascript">delete person.name;</code></pre>
<h3 id="setter-amp-getter"><a href="#setter-amp-getter" class="headerlink" title="setter &amp; getter"></a>setter &amp; getter</h3><p>创建对象时添加 getter 和 setter：</p>
<pre><code class="javascript">const person = {
    firstName: &quot;三&quot;,
    lastName: &quot;张&quot;,
    get fullName() {
        return this.lastName + this.firstName;
    },
    set fullName(fullname) {
        let [lastname, firstname] = fullname.split(&quot;,&quot;);
        this.lastName = lastname;
        this.firstName = firstname;
    }
}

console.log(person.fullName);
person.fullName = &quot;李,四&quot;;
console.log(person.fullName);</code></pre>
<p>在使用构造函数时候，添加 getter 和 setter：</p>
<pre><code class="javascript">function Employee(name, position) {
    this.name = name;
    this.position = position;
}

const emp = new Employee(&quot;张三&quot;, &quot;前端工程师&quot;);

Object.defineProperty(emp, &quot;info&quot;,  {
    get: function() {
        return this.name + &quot; &quot; + this.position;
    },
    set: function(info) {
        let [name, position] = info.split(&quot; &quot;);
        this.name = name;
        this.position = position;
    }
})

console.log(emp.info);
emp.info = &quot;赵四 后端工程师&quot;;
console.log(emp.info);

</code></pre>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>这个“原型”，我个人猜测是一个看不见的父类，这个Student函数在调用 new 的时候，才会产生这个原型，原型的属性是通过Student中的具体内容而生成的。后面每一个生成的“实例对象”都会按照这个原型进行“一比一复制”，这个原型里有什么属性就会“复制”过来什么属性，有什么方法就会“复制”过来什么方法，同时在这个原型里，会在调用 new 之后，添加一个名为 constructor 的属性（函数），即生成某个对象的构造函数，该函数的最大作用是初始化！且要注意的是，是对创建的 “实例对象” 初始化！上一些代码来做详细说明：</p>
<pre><code class="javascript">function Student(name) {
    this.name = name;
    this.hello = function () {
        alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
    }
}

var xiaoming = new Student(&#39;小明&#39;);
xiaoming.name; // &#39;小明&#39;
xiaoming.hello(); // Hello, 小明!</code></pre>
<p>这里的 Student 构造函数实际上就是对 xiaoming 对象其初始化的作用，Student 就理解成是对 “Student” 这个 “类” 的构造函数就可以了。那这个原型，到底长啥样的？以下是我个人对其大致的猜测：</p>
<pre><code class="javascript">var prototype = {
    name: undefined,
    hello: undefined,
    constructor: Student(name)
}

function Student(name) {
    this.name = name;
    this.hello = function () {
        alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
    }
}</code></pre>
<p>其原型的产生时间点还猜不到，感觉应该是一个函数定义出来的时候，其原型就会存在了吧。new 之后就会产生这样一个唯一原型，也可以说是唯一 “父类”，在创建对象的时候，调用 constructor，也就是 Student 这个（构造）函数，然后在里面对 name 和 hello 进行初始化。所以，它的实现本质就是使用了闭包！</p>
<p><img src="https://images-1259064069.cos.ap-guangzhou.myqcloud.com/images/image-20200809020228423.png" alt="image-20200809020228423"></p>
<p>另外，函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。</p>
<p>这里再加一下个人见解：之所以让 Student 去获取 prototype 的原因是因为，按照正常的逻辑只有父类自己才能修改自己，而实例对象是没权利修改这个原型的，所以说，实例对象不提供 xiaohong 这个 prototype 这个属性。但是，通过所谓的 <code>__proto__</code> 来查看，我个人觉得应该是利用了类似 Java 映射的原理，强行查看到的。就有点像 Java 中使用 <code>.class()</code> 获取其字节码文件一个道理，应用到这面就很好理解了。</p>
<p>另外还要说一下共享方法的问题：</p>
<pre><code class="javascript">xiaoming.name; // &#39;小明&#39;
xiaohong.name; // &#39;小红&#39;
xiaoming.hello; // function: Student.hello()
xiaohong.hello; // function: Student.hello()
xiaoming.hello === xiaohong.hello; // false</code></pre>
<p>这里生成俩对象，但是他俩的 hello 方法确实不一样的，所以说创建对象的时候，这个方法都是被各自所拥有，可是他俩代码是一样的，为了优化，可以把这个方法在 Student 构造函数里删掉，然后手动添加到 Student 的原型里。这样，虽然实例对象（子类）中没有这个叫 hello 的方法，它就会去它的原型（父类）里去找。</p>
<pre><code class="javascript">function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
};</code></pre>
<p>其原型内的内容大概就会变成这样：</p>
<pre><code class="javascript">var prototype = {
    name: undefined,
    hello: function () {
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);}，
    constructor: Student(name),
}

function Student(name) {
    this.name = name;
}</code></pre>
<p>注意一点，这样写的话，实例对象中是没有 hello 这个方法的！为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如<a href="http://www.jslint.com/" target="_blank" rel="noopener">jslint</a>将可以帮你检测到漏写的<code>new</code>。</p>
<h3 id="createXXX"><a href="#createXXX" class="headerlink" title="createXXX()"></a>createXXX()</h3><p>继续上面的例子说，分开是因为，个人觉得这块内容又涉及到另外的知识了。</p>
<p>我们还可以编写一个<code>createStudent()</code>函数，在内部封装所有的<code>new</code>操作。一个常用的编程模式像这样：</p>
<pre><code class="javascript">function Student(props) {
    this.name = props.name || &#39;匿名&#39;; // 默认值为&#39;匿名&#39;
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
};

function createStudent(props) {
    return new Student(props || {})
}</code></pre>
<p>上面这个 props 传进来的是一个对象！注意是一个对象！</p>
<p>这个<code>createStudent()</code>函数有几个巨大的优点：一是不需要<code>new</code>来调用，二是参数非常灵活，可以不传，也可以这么传：</p>
<pre><code class="javascript">var xiaoming = createStudent({
    name: &#39;小明&#39;
});

xiaoming.grade; // 1</code></pre>
<p>如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从<code>JSON</code>拿到了一个对象，就可以直接创建出<code>xiaoming</code>。</p>
<p>再加一下个人的小总结：这么写的话，反序列化的时候就会非常方便，得到某一个“类”的实例对象之后，就直接把它传进来，就可以直接生成一个一模一样的对象。</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>上面如果理解了，这块估计也差不多了，直接上其实现的大概情况：</p>
<pre><code class="javascript">var prototype = {
    name: undefined,
    hello: undefined,
    grade: undefined,
    constructor: PrimaryStudent(props)
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

function Student(name) {
    this.name = name;
    this.hello = function () {
        alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
    }
}</code></pre>
<p>具体的实现过程：</p>
<pre><code class="javascript">// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: &#39;小明&#39;,
    grade: 2
});
xiaoming.name; // &#39;小明&#39;
xiaoming.grade; // 2</code></pre>
<p>一开始用一个空函数的原型对象指向原 Student 的原型对象（有constructor），所以再 new F() 的时候，其实是创建了一个空的 Student 对象，因为没参数，所以 name 和 hello 依旧是undefined，继承在这时候应该就算已经发生了。再之后把 PrimaryStudent 的原型里，添加上 constructor 函数，就成了！而后面那个 getGrade 只是再起原型基础上继续添加新方法而已。原型里的 grade 这个属性，是在 PrimaryStudent 这个构造函数里，直接新创建一个属性给其原型。</p>
<p>如果把继承这个动作用一个<code>inherits()</code>函数封装起来，还可以隐藏<code>F</code>的定义，并简化代码：</p>
<pre><code class="javascript">function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}</code></pre>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>JavaScript的原型继承实现方式就是：</p>
<ol>
<li>定义新的构造函数，并在内部用<code>call()</code>调用希望“继承”的构造函数，并绑定<code>this</code>；</li>
<li>借助中间函数<code>F</code>实现原型链继承，最好通过封装的<code>inherits</code>函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。</li>
</ol>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class 的使用基本和 Java 一毛一样，直接上代码就完事了：</p>
<pre><code class="javascript">class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
    }
}</code></pre>
<p>继承的话就是：</p>
<pre><code class="javascript">class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert(&#39;I am at grade &#39; + this.grade);
    }
}</code></pre>
<p>也是用 super 给父类的构造函数传参，特有的用 this.XXX 创建并赋值。</p>
<p><strong>注意：</strong>因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把<code>class</code>代码转换为传统的<code>prototype</code>代码，可以试试<a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>这个工具。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 lding1003@gmail.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MDU2Ni8yNzA0OQ==">
        <script type="text/javascript">
			(function(d, s) {
				var j, e = d.getElementsByTagName(s)[0];

				if (typeof LivereTower === 'function') { return; }

				j = d.createElement(s);
				window.livereOptions = {
					eagerLoading: true,
					scrollEventTargetSelector: '#post'
                }
				j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
				j.async = true;
				e.parentNode.insertBefore(j, e);
			})(document, 'script');
        </script>
        <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2019-2020 黑刀
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
